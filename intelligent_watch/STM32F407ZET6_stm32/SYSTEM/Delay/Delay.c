/**
   ******************************************************************************
   * @file    STM32F407ZET6_外设完备版\SYSTEM\Delay.c 
   * @author  xzdtx2333@outlook.com
   * @version V1.0.0
   * @date    2024-07-09
   * @brief   用systick产生us、ms、s级别的定时
   ******************************************************************************
   * 
   ******************************************************************************
**/

#include "Delay.h"

/**
   ******************************************************************************
   * @brief		此功能有两个关键参数，预分频值和自动重装载值，可通过函数配置分频
   *			值，也可像下方一样通过寄存器设置。得到了分频后的频率后，自动重装
   *			载值决定了计数周期，也就是延多少时。具体过程是这样的：当前值寄存
   *			器从自动重装载寄存器那里获取设定的值，当前值寄存器的值从设定值到
   *			0（用递减计数），一共经历了一个定时器的时钟周期，而这个时钟周期
   *			的值，是用分频后的频率/自动重装载值得到得。比如分频后的频率为
   *			21000000，自动重装载值为21，那么定时器周期就是21000000/21=
   *			1000000=1us，也就是说，当前值寄存器中的值从设定值到0，共经历了1us
   *			以此达到定时的目的
   ******************************************************************************
   * 
   ******************************************************************************
**/

#if RTOS_DELAY
//延时微秒 	非阻塞
void Delay_us(u32 nus)
{
	int  sum  = 0;             //作为计数器，对递减次数进行累加
	int  load = SysTick->LOAD; //把Systick的重载寄存器的值备份 
	int  told = 0;						 //用于存储读取的Systick的VAL寄存器的第1次的值
	int  tnew = 0;             //用于存储读取的Systick的VAL寄存器的第2次的值

	told = SysTick->VAL;       //读取第1次

	while(1)
	{
		tnew = SysTick->VAL ;  //读取第2次
		
		if(told != tnew)
		{
			//此时分为2种情况：told > tnew (一轮之内)  or   told < tnew (一轮之外)
			if(told > tnew)
			{
				sum += told - tnew;
			}						
			else
			{
				sum += load - tnew + told;
			}
			
			told = tnew;
			
			//判断递减次数之和是否达到延时时间对应的计数次数
			if(sum >= nus*168)
			{
				break;
			}
		}
	}
}

//延时毫秒 
void Delay_ms(uint32_t nms)
{
	while(nms--)
	{
		Delay_us(1000);
	}
}

/*用ms延时来实现s延时*/
void Delay_s(uint32_t ns)
{
	while(ns--)
	{
		Delay_ms(1000);
	}
}
#else
void Delay_us(uint32_t xus)
{
	/*每次计数周期为1us，原理查内核手册，所以循环多少次就是多少us*/ 
	
	while(xus--)
	{
		SysTick->CTRL 	= 	0; 			/*	控制与状态寄存器，0位段：1开0关*/
		SysTick->LOAD 	= 	21 - 1; 	/*	重装载值寄存器，决定定时周期*/
		SysTick->VAL 	= 	0; 			/*	当前数值寄存器，写它可使之清零，还会
											清除CTRL中COUNTFLAG标志，具体作用查内核手册*/
		SysTick->CTRL 	= 	1; 			/*	先关，再配置LOAD，清零VAL，再开*/
		
		while ((SysTick->CTRL & 0x00010000)==0);	/*	16位段是COUNTFLAG标志，为1则表示
														数完了，可以退出循环了*/
	}
	
	SysTick->CTRL 	= 	0; 				/*	数完之后要关闭定时器*/
}

void Delay_ms(uint32_t xms)
{
	/*每次计数周期为1ms，原理查内核手册，所以循环多少次就是多少ms*/ 
	
	while(xms--)
	{
		SysTick->CTRL 	= 	0; 						/*	控制与状态寄存器，0位段：1开0关*/
		SysTick->LOAD 	= 	(21 * 1000) - 1; 		/*	重装载值寄存器，决定定时周期*/
		SysTick->VAL 	= 	0; 						/*	当前数值寄存器，写它可使之清零，还会*/
		SysTick->CTRL 	= 	1; 						/*	清除CTRL中COUNTFLAG标志，具体作用查内核手册
														先关，再配置LOAD，清零VAL，再开*/
		while ((SysTick->CTRL & 0x00010000)==0);	/*	16位段是COUNTFLAG标志，为1则表示
															数完了，可以退出循环了*/
	}
	
	SysTick->CTRL = 0; /*	数完之后要关闭定时器*/
}

/*用ms延时来实现s延时*/
void Delay_s(uint32_t ns)
{
	int i;
	
	for(i=0; i<ns; i++)
	{
		Delay_ms(1000);
	}
}
#endif
